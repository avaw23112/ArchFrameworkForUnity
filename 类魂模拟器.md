# 类魂模拟器

1. # 框架

    1. ## 特性

        1. 定义：具备可拓展性，使用快捷的特性工具

            1. <span id="20250915220653-6vlga8r" style="display: none;"></span>可拓展性：具体功能完全由可拓展部分实现，核心代码只提供功能所需数据。
            2. <span id="20250915220659-i25hgdl" style="display: none;"></span>使用快捷：需要了解的接口少，认知负担低。
        2. 作用：方便开发者快速制定代码工具。
        3. 组件：

            1. ![image](assets/image-20250915214312-rk9s43b.png)
            2. Attributes：

                1. 存储收集到的所有被BaseAttribute标注的值对
                2. 将收集到的键值提供给对应的属性系统
                3. 注册并调用属性系统
            3. Collector：

                1. 收集所有属性的键值对
                2. 收集制定的接口的键值对
            4. BaseAttribute：可派生的特性
            5. CollectableBaseAttribute: 用于需要集中处理的特性。比如Before,After同时标注一个类时，只处理Before，只处理After的系统都无法获得键值对。只有同时处理Before和After的系统才能获得键值对。
            6. Assemblys:收集项目中的程序集
            7. AttributeSystem：可派生的特性处理系统，用于处理指定的、收集到的键值对。
            8. MultiAttributeSystem：可派生的，用于处理可多次标注的特性。
        4. 接口：

            1. AttributeSystem
            2. MultiAttributeSystem
            3. BaseAttribute
            4. CollectableBaseAttribute
    2. ## ECS

        1. 定义：具备可拓展性，使用快捷的系统创建工具
        2. 作用：给开发者提供可拓展可定制的系统功能
        3. 组成：

            1. ![image](assets/image-20250917223613-tuudq39.png)
        4. 接口：

            1. System集合

                1. PureSystem：ISystem系列接口继承的类会被直接调用

                    1. IAwake:在植入PlayerLoop时自动调用
                    2. IUpdate:每帧自动调用，先于ReactiveUpdateSystem调用
                    3. ILateUpdate:每帧Update后自动调用，晚于ReactiveLateUpdateSystem
                    4. IDestroy：在系统结束前自动调用
                2. ReactiveSystem:IReactive系列接口继承的类会内置对实体的Query

                    1. IReactive:指定特定组件，当带有该组件的实体被创建时，自动将实体回调给接口。
                    2. IReactiveAwake:实体创建时回调
                    3. IReactiveUpdate:每帧查询拥有对应组件的实体，并ref返回
                    4. IReactiveLateUpdate:每帧Update后查询拥有对应组件的实体，并ref返回。早于ILateUpdate
                    5. IReactiveDestroy:在实体销毁时回调
            2. SystemAttribute

                1. 标记该类属于某系统，并入PlayerLoop的插入中
    3. ## 事件总线

        1. 定义：具备可拓展性，使用快捷的模块解耦工具

            1. [可拓展性](#20250915220653-6vlga8r)，[使用快捷](#20250915220659-i25hgdl)
            2. 模块解耦：使不同模块间可异步开发，功能互相独立
        2. 作用：

            1. 本地：实现不同模块间的同步通信与异步通信。
            2. 网络：实现ActorRPC通信，Actor通信，RPC通信，Message通信
        3. 组成：

            1. ![image](assets/image-20250915220312-c17ex0d.png)
        4. 接口：

            1. EventBus:使用Publish发布事件
            2. Event<T>:可继承得到事件反馈
    4. ## 资源管理

        1. 作用：

            1. 给出一套资源定义规范，形成资源导入工作流
            2. 实现资源的分层管理，分层释放，分层读取功能
            3. 实现资源更新预加载功能
            4. 实现代码热更新功能
        2. 定义

            1. 负责管理代码、资源的热更新，提供一套资源导入规范的工具。
        3. 组成

            1. ArchRes:对外提供资源获取接口

                1. 资源异步加载
                2. 资源同步加载
                3. 资源释放
                4. 资源销毁
                5. 资源强制销毁
            2. ResLayer:存储资源分组的路径和层级设定
            3. ResHandleManager:管理资源读取后的handle

                1. 引用计数管理
                2. 资源强制清理
                3. 资源释放
            4. HotFixCodeLoader:热更代码加载

                1. 加载热更代码，本地+远程
    5. ## 热重载功能

        1. 热更新步骤

            1. 触发热更新

                1. 收集热重载的源码
                2. 收集热重载源码的引用dll
            2. 编译热更新代码

                1. 用Roslyn的API，编译收集来的源码以及链接dll
            3. 动态加载热更新代码

                1. 加载热重载dll
                2. 重新收集属性，构建属性系统。
                3. 重置PlayerLoop。
            4. 重载程序
            5. 问题：

                1. 根据的是上一次的Dll的引用来编译新源码，当新源码使用新程序集时，导致无法编译成功。
                2. 资源管理器检测到文件变化会重置域。
            6. 目前方向

                1. 将代码项目放在Asset外，然后动态读取编译出来的dll文件

                    1. 热更新：探索Addressables能否热更Assets外的文件
                    2. 好处：自定义编译流程，避免用分析器编译代码的窘迫。（新源码的引用问题）
                    3. 坏处：华佗热更新不知道能不能支持。不过现在是以DLL方式读取热更代码，貌似也不需要华佗？）
                    4. 日志

                        1. 首先看看能不能让其参与Addressables的热更新，即外部代码能否参与热更，还是说必须要放在Assets下的资源才能热更？
                        2. 思路

                            1. Addressables中占位两个空的bytes，等打包时把编译好的dll注入进去。编辑器模式下直接导入编译好的dll，而运行时加载addressables标注的bytes文件。
                        3. 如何配置一个Assets外的项目，且可以用像被unity管理一样使用它的资源？
                        4. 构建一个方法，读取文件外的dll。
                        5. 华佗热更新到底需不需要代码在Assets目录下？
                2. 还是将代码留在Asset里面，关闭脚本域重载。

                    1. 好处：只是动态读取新的dll，不影响华佗热更新。
                    2. 坏处：使用Roslyn编译，容易查询引用错误。
                3. 先不考虑打包流程，我们先把热重载做完。
            7. 最终实现方案

                1.
        2. 热更新的核心

            1. 允许逻辑重载，但数据必须保持不变。

                1. 在ECS框架中体现，即Model层的组件不可热重载，而Logic层的系统全都可热重载。
        3. 下一步

            1. 分离Model,HotFix，保证数据不可热重载，逻辑可热重载
            2. 分离Hotfix代码出Unity，保证Unity不编译Hotfix代码，完成热更新。
            3. 用额外的存储地存放上一次hotfix.dll所在地？或者能否直接检查目前代码所引用的dll，动态获取？
        4. 技术点

            1. link.xml文件提取AOT裁剪代码
            2. 业务逻辑内只引用AOT代码来编译
    6. ## 网络

        1. 步骤拆解

            1. KCP集成：https://github.com/KumoKyaku/kcp.git
            2. MemoryPack兼容华佗方法

                1. MemoryPack由于程序集动态类型不一致问题，无法在AOT.dll内收集热更新.dll的序列化器，无法反序列化。
            3. ENet集成
            4. 构建底层通信组件Session
            5. RPC通信实现
        2. 总结

            1. 要实现网络透明化，要从以下几个方面入手

                1. 序列化

                    1. 必须采用序列化器 ， 序列化组件分离的方式。目的是方便在AOT代码中注册序列化器，避免动态类型不匹配问题。（MemoryPack因为这个原因，无法从热更新dll注册序列化器）

                        1. 序列化算法和反序列化算法：要求在序列化和反序列时，不能使用动态类型相关，避免热更新类型不匹配问题。
                        2. 实现chunk同步包

                            1. 该包要包含需要同步的worldID，Archetype，chunk块的标识，Sync组件集，EntityID集。
                            2. 其中Sync组件集和EntityID集要对应，chunk块标识用于在对应world的哪个chunk,Archetype用于在World不存在该ArcheType时创建出来。Sync组件集，EntityID集就是同步对象了。
                            3. 思路

                                1. 提前通过IComponent的Type注册`ComponentType`，再通过`ComponentType`直接注册进`ComponentRegistry`，而后双端就能只通过`ComponentType`.id就能实现互相还原world了。
                        3. 源生成器：自动实现序列化和反序列化器，简化代码。
                2. 网络框架

                    1. 在序列化算法的基础上，利用LitNetLib实现可靠UDP通信框架

                        1. 以组件的方式实现Session管理器，方便调度socket。
                        2. 心跳机制实现。
                        3. 预测回滚力度智能调控。
                3. 以chunk为基础的同步组件收集，避免离散收集

                    1. 底层：保证客户端的world以及chunk都和服务端完全一致即可。
                    2. 优化：利用chunk的连续性，一次性收集所有需要同步的组件一起发送。
                    3. 高级特性：

                        1. 增量同步
                        2. 插值
                        3. 预测回滚
        3. MemoryPack 兼容华佗
        4. 华佗热更新导致生成的代码也必须在Model下，但序列化是否需要AOT代码引用Model里自动生成代码？
        5. 网络透明化：自动同步组件。插值 ， 同步rate
        6. 底层Chunk同步
        7. 0GC网络同步
        8. P2P + C/S联机
        9. SIMD兼容
        10. 帧同步兼容
    7. ## 加载速度优化
    8. ## 渲染

        1. ### URP管线
        2. ### Shader Graph制作PBR材质
    9. ## 物理
    10. ## 配置表读取

         1. Luban配置
    11. # UI
    12. ## 优先级系统

         1. 需求分析

             1. 以ECS架构，制作层状优先树。
             2. 以ECS架构，制作有限状态机。
             3. 层状优先树存储Key + 优先级。Key用于匹配当前的目标资源，优先级用于记录目标资源的替换优先级。当外界的有限状态机想改变状态，首先用当前的状态的key值找到在优先树中的位置，然后匹配目标状态的位置，如果优先级不足就禁止有限状态机切换。本质上，层级优先树是状态机的一个中间层，目的是给状态的转变施加外界规则。
         2. 资源整理

             1.
         3. 测试用例覆盖
         4. 代码编写
    13. ## 动作
    14. ## 音效
    15. ## 特效
    16. ## 玩家

         1. ### 技能
         2. ### 数值属性
         3. ### 3C
         4. ### 反馈
    17. ## 怪物编辑
    18. ## 地图编辑
    19. ## 性能优化

         1. ### Burst强化
         2. ### JobSystem

‍
