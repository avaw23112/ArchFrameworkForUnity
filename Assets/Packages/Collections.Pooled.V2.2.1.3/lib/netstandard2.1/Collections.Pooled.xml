<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Collections.Pooled</name>
    </assembly>
    <members>
        <member name="M:Collections.Pooled.BitHelper.ToIntArrayLength(System.Int32)">
            <summary>How many ints must be allocated to represent n bits. Returns (n+31)/32, but avoids overflow.</summary>
        </member>
        <member name="T:Collections.Pooled.ClearMode">
            <summary>
            This enum allows control over how data is treated when internal
            arrays are returned to the ArrayPool. Be careful to understand 
            what each option does before using anything other than the default
            of Auto.
            </summary>
        </member>
        <member name="F:Collections.Pooled.ClearMode.Auto">
            <summary>
            <para><code>Auto</code> has different behavior depending on the host project's target framework.</para>
            <para>.NET Core 2.1: Reference types and value types that contain reference types are cleared
            when the internal arrays are returned to the pool. Value types that do not contain reference
            types are not cleared when returned to the pool.</para>
            <para>.NET Standard 2.0: All user types are cleared before returning to the pool, in case they
            contain reference types.
            For .NET Standard, Auto and Always have the same behavior.</para>
            </summary>
        </member>
        <member name="F:Collections.Pooled.ClearMode.Always">
            <summary>
            The <para><code>Always</code> setting has the effect of always clearing user types before returning to the pool.
            This is the default behavior on .NET Standard.</para><para>You might want to turn this on in a .NET Core project
            if you were concerned about sensitive data stored in value types leaking to other pars of your application.</para> 
            </summary>
        </member>
        <member name="F:Collections.Pooled.ClearMode.Never">
            <summary>
            <para><code>Never</code> will cause pooled collections to never clear user types before returning them to the pool.</para>
            <para>You might want to use this setting in a .NET Standard project when you know that a particular collection stores
            only value types and you want the performance benefit of not taking time to reset array items to their default value.</para>
            <para>Be careful with this setting: if used for a collection that contains reference types, or value types that contain
            reference types, this setting could cause memory issues by making the garbage collector unable to clean up instances
            that are still being referenced by arrays sitting in the ArrayPool.</para>
            </summary>
        </member>
        <member name="T:Collections.Pooled.IReadOnlyPooledList`1">
            <summary>
            Represents a read-only collection of pooled elements that can be accessed by index
            </summary>
            <typeparam name="T">The type of elements in the read-only pooled list.</typeparam>
        </member>
        <member name="P:Collections.Pooled.IReadOnlyPooledList`1.Span">
            <summary>
            Gets a <see cref="T:System.ReadOnlySpan`1"/> for the items currently in the collection.
            </summary>
        </member>
        <member name="T:Collections.Pooled.NonRandomizedStringEqualityComparer">
            <summary>
            NonRandomizedStringEqualityComparer is the comparer used by default with the PooledDictionary.
            We use NonRandomizedStringEqualityComparer as default comparer as it doesnt use the randomized string hashing which 
            keeps the performance not affected till we hit collision threshold and then we switch to the comparer which is using 
            randomized string hashing.
            </summary>
        </member>
        <member name="T:Collections.Pooled.InsertionBehavior">
            <summary>
            Used internally to control behavior of insertion into a <see cref="T:Collections.Pooled.PooledDictionary`2"/>.
            </summary>
        </member>
        <member name="F:Collections.Pooled.InsertionBehavior.None">
            <summary>
            The default insertion behavior.
            </summary>
        </member>
        <member name="F:Collections.Pooled.InsertionBehavior.OverwriteExisting">
            <summary>
            Specifies that an existing entry with the same key should be overwritten if encountered.
            </summary>
        </member>
        <member name="F:Collections.Pooled.InsertionBehavior.ThrowOnExisting">
            <summary>
            Specifies that if an existing entry with the same key is encountered, an exception should be thrown.
            </summary>
        </member>
        <member name="T:Collections.Pooled.PooledDictionary`2">
            <remarks>
            A <see cref="T:Collections.Pooled.PooledDictionary`2"/> can support multiple readers concurrently, as long as the collection is not modified. 
            Even so, enumerating through a collection is intrinsically not a thread-safe procedure. 
            In the rare case where an enumeration contends with write accesses, the collection must be locked during the entire enumeration. 
            To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization. 
            </remarks>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(Collections.Pooled.ClearMode)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Int32)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Int32,Collections.Pooled.ClearMode)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(Collections.Pooled.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Int32,Collections.Pooled.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},Collections.Pooled.ClearMode)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},Collections.Pooled.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},Collections.Pooled.ClearMode)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},Collections.Pooled.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}},Collections.Pooled.ClearMode)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}},Collections.Pooled.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.ValueTuple{`0,`1}[])">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.ValueTuple{`0,`1}[],Collections.Pooled.ClearMode)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.ValueTuple{`0,`1}[],System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.ValueTuple{`0,`1}[],Collections.Pooled.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.ReadOnlySpan{System.ValueTuple{`0,`1}})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.ReadOnlySpan{System.ValueTuple{`0,`1}},Collections.Pooled.ClearMode)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.ReadOnlySpan{System.ValueTuple{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.ReadOnlySpan{System.ValueTuple{`0,`1}},Collections.Pooled.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledDictionary`2.Comparer">
            <summary>
            The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> used to compare keys in this dictionary.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledDictionary`2.Count">
            <summary>
            The number of items in the dictionary.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledDictionary`2.KeyClearMode">
            <summary>
            Returns the ClearMode behavior for the collection, denoting whether values are
            cleared from internal arrays before returning them to the pool.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledDictionary`2.ValueClearMode">
            <summary>
            Returns the ClearMode behavior for the collection, denoting whether values are
            cleared from internal arrays before returning them to the pool.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledDictionary`2.Keys">
            <summary>
            The keys in this dictionary.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledDictionary`2.Values">
            <summary>
            The values in this dictionary.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledDictionary`2.Item(`0)">
            <summary>
            Gets or sets an item in the dictionary by key.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.Add(`0,`1)">
            <summary>
            Adds a key/value pair to the dictionary.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Allows child classes to add their own serialization data.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the dictionary can hold up to 'capacity' entries without any further expansion of its backing storage
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.TrimExcess">
            <summary>
            Sets the capacity of this dictionary to what it would be if it had been originally initialized with all its entries
            
            This method can be used to minimize the memory overhead 
            once it is known that no new elements will be added. 
            
            To allocate minimum size storage array, execute the following statements:
            
            dictionary.Clear();
            dictionary.TrimExcess();
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledDictionary`2.TrimExcess(System.Int32)">
            <summary>
            Sets the capacity of this dictionary to hold up 'capacity' entries without any further expansion of its backing storage
            
            This method can be used to minimize the memory overhead 
            once it is known that no new elements will be added. 
            </summary>
        </member>
        <member name="T:Collections.Pooled.PooledExtensions">
            <summary>
            Extension methods for creating pooled collections.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:Collections.Pooled.PooledDictionary`2"/> from an <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to specified 
            key selector and element selector functions, as well as a comparer.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledDictionary``3(System.ReadOnlySpan{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:Collections.Pooled.PooledDictionary`2"/> from a <see cref="T:System.ReadOnlySpan`1"/> according to specified 
            key selector and element selector functions, as well as a comparer.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledDictionary``3(System.Span{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:Collections.Pooled.PooledDictionary`2"/> from a <see cref="T:System.Span`1"/> according to specified 
            key selector and element selector functions, as well as a comparer.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledDictionary``3(System.ReadOnlyMemory{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:Collections.Pooled.PooledDictionary`2"/> from a <see cref="T:System.ReadOnlyMemory`1"/> according to specified 
            key selector and element selector functions, as well as a comparer.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledDictionary``3(System.Memory{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:Collections.Pooled.PooledDictionary`2"/> from a <see cref="T:System.Memory`1"/> according to specified 
            key selector and element selector functions, as well as a comparer.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:Collections.Pooled.PooledDictionary`2"/> from an <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to specified 
            key selector and comparer.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledDictionary``2(System.ReadOnlySpan{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:Collections.Pooled.PooledDictionary`2"/> from an <see cref="T:System.ReadOnlySpan`1"/> according to specified 
            key selector and comparer.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledDictionary``2(System.Span{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:Collections.Pooled.PooledDictionary`2"/> from an <see cref="T:System.Span`1"/> according to specified 
            key selector and comparer.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledDictionary``2(System.ReadOnlyMemory{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:Collections.Pooled.PooledDictionary`2"/> from an <see cref="T:System.ReadOnlyMemory`1"/> according to specified 
            key selector and comparer.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledDictionary``2(System.Memory{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:Collections.Pooled.PooledDictionary`2"/> from an <see cref="T:System.Memory`1"/> according to specified 
            key selector and comparer.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledDictionary``2(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1}},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates a <see cref="T:Collections.Pooled.PooledDictionary`2"/> from a sequence of key/value tuples.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledDictionary``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates a <see cref="T:Collections.Pooled.PooledDictionary`2"/> from a sequence of KeyValuePair values.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledDictionary``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates a <see cref="T:Collections.Pooled.PooledDictionary`2"/> from a sequence of key/value tuples.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledDictionary``2(System.ReadOnlySpan{System.ValueTuple{``0,``1}},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates a <see cref="T:Collections.Pooled.PooledDictionary`2"/> from a span of key/value tuples.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledDictionary``2(System.Span{System.ValueTuple{``0,``1}},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates a <see cref="T:Collections.Pooled.PooledDictionary`2"/> from a span of key/value tuples.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledStack``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an instance of PooledStack from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledStack``1(``0[])">
            <summary>
            Creates an instance of PooledStack from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledStack``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates an instance of PooledStack from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledStack``1(System.Span{``0})">
            <summary>
            Creates an instance of PooledStack from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledStack``1(System.ReadOnlyMemory{``0})">
            <summary>
            Creates an instance of PooledStack from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledStack``1(System.Memory{``0})">
            <summary>
            Creates an instance of PooledStack from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledQueue``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an instance of PooledQueue from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledQueue``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates an instance of PooledQueue from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledQueue``1(System.Span{``0})">
            <summary>
            Creates an instance of PooledQueue from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledQueue``1(System.ReadOnlyMemory{``0})">
            <summary>
            Creates an instance of PooledQueue from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledQueue``1(System.Memory{``0})">
            <summary>
            Creates an instance of PooledQueue from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledQueue``1(``0[])">
            <summary>
            Creates an instance of PooledQueue from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledMemory``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Create an instance of PooledMemory from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledMemory``1(``0[])">
            <summary>
            Create an instance of PooledMemory from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledMemory``1(System.ReadOnlySpan{``0})">
            <summary>
            Create an instance of PooledMemory from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledMemory``1(System.Span{``0})">
            <summary>
            Create an instance of PooledMemory from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledMemory``1(System.ReadOnlyMemory{``0})">
            <summary>
            Create an instance of PooledMemory from the given items.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledExtensions.ToPooledMemory``1(System.Memory{``0})">
            <summary>
            Create an instance of PooledMemory from the given items.
            </summary>
        </member>
        <member name="T:Collections.Pooled.PooledList`1">
            <summary>
            Implements a variable-size list that uses a pooled array to store the
            elements. A PooledList has a capacity, which is the allocated length
            of the internal array. As elements are added to a PooledList, the capacity
            of the PooledList is automatically increased as required by reallocating the
            internal array.
            </summary>
            <remarks>
            This class is based on the code for <see cref="T:System.Collections.Generic.List`1"/> but it supports <see cref="T:System.Span`1"/>
            and uses <see cref="T:System.Buffers.ArrayPool`1"/> when allocating internal arrays.
            </remarks>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor">
            <summary>
            Constructs a PooledList. The list is initially empty and has a capacity
            of zero. Upon adding the first element to the list the capacity is
            increased to DefaultCapacity, and then increased in multiples of two
            as required.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(Collections.Pooled.ClearMode)">
            <summary>
            Constructs a PooledList. The list is initially empty and has a capacity
            of zero. Upon adding the first element to the list the capacity is
            increased to DefaultCapacity, and then increased in multiples of two
            as required.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a PooledList. The list is initially empty and has a capacity
            of zero. Upon adding the first element to the list the capacity is
            increased to DefaultCapacity, and then increased in multiples of two
            as required.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a PooledList. The list is initially empty and has a capacity
            of zero. Upon adding the first element to the list the capacity is
            increased to DefaultCapacity, and then increased in multiples of two
            as required.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.Int32)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.Int32,Collections.Pooled.ClearMode)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.Int32,Collections.Pooled.ClearMode,System.Boolean)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.Int32,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.Int32,System.Buffers.ArrayPool{`0},System.Boolean)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.Int32,Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.Int32,Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0},System.Boolean)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
            <param name="sizeToCapacity">If true, Count of list equals capacity. Depending on ClearMode, rented items may or may not hold dirty values.</param>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(`0[])">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(`0[],Collections.Pooled.ClearMode)">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(`0[],System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(`0[],Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.ReadOnlySpan{`0},Collections.Pooled.ClearMode)">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.ReadOnlySpan{`0},System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.ReadOnlySpan{`0},Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size of the new list will be equal to the size of the given collection
            and the capacity will be equal to suggestCapacity
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.Collections.Generic.IEnumerable{`0},Collections.Pooled.ClearMode)">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.#ctor(System.Collections.Generic.IEnumerable{`0},Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0},System.Int32)">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledList`1.Span">
            <summary>
            Gets a <see cref="T:System.Span`1"/> for the items currently in the collection.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledList`1.Collections#Pooled#IReadOnlyPooledList{T}#Span">
            <inheritdoc/>
        </member>
        <member name="P:Collections.Pooled.PooledList`1.Capacity">
            <summary>
            Gets and sets the capacity of this list.  The capacity is the size of
            the internal array used to hold items.  When set, the internal 
            Memory of the list is reallocated to the given capacity.
            Note that the return value for this property may be larger than the property was set to.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledList`1.Count">
            <summary>
            Read-only property describing how many elements are in the List.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledList`1.ClearMode">
            <summary>
            Returns the ClearMode behavior for the collection, denoting whether values are
            cleared from internal arrays before returning them to the pool.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledList`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the given index.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.Add(`0)">
            <summary>
            Adds the given object to the end of this list. The size of the list is
            increased by one. If required, the capacity of the list is doubled
            before adding the new element.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the elements of the given collection to the end of this list. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.AddRange(`0[])">
            <summary>
            Adds the elements of the given array to the end of this list. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.AddRange(System.ReadOnlySpan{`0})">
            <summary>
            Adds the elements of the given <see cref="T:System.ReadOnlySpan`1"/> to the end of this list. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.AddSpan(System.Int32)">
            <summary>
            Advances the <see cref="P:Collections.Pooled.PooledList`1.Count"/> by the number of items specified,
            increasing the capacity if required, then returns a Span representing
            the set of items to be added, allowing direct writes to that section
            of the collection.
            </summary>
            <param name="count">The number of items to add.</param>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
             <summary>
             Searches a section of the list for a given element using a binary search
             algorithm. 
             </summary>
             
             <remarks><para>Elements of the list are compared to the search value using
             the given IComparer interface. If comparer is null, elements of
             the list are compared to the search value using the IComparable
             interface, which in that case must be implemented by all elements of the
             list and the given search value. This method assumes that the given
             section of the list is already sorted; if this is not the case, the
             result will be incorrect.</para>
            
             <para>The method returns the index of the given value in the list. If the
             list does not contain the given value, the method returns a negative
             integer. The bitwise complement operator (~) can be applied to a
             negative result to produce the index of the first element (if any) that
             is larger than the given search value. This is also the index at which
             the search value should be inserted into the list in order for the list
             to remain sorted.
             </para></remarks>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.BinarySearch(`0)">
            <summary>
            Searches the list for a given element using a binary search
            algorithm. If the item implements <see cref="T:System.IComparable`1"/>
            then that is used for comparison, otherwise <see cref="P:System.Collections.Generic.Comparer`1.Default"/> is used.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Searches the list for a given element using a binary search
            algorithm. If the item implements <see cref="T:System.IComparable`1"/>
            then that is used for comparison, otherwise <see cref="P:System.Collections.Generic.Comparer`1.Default"/> is used.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.Clear">
            <summary>
            Clears the contents of the PooledList.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.Contains(`0)">
            <summary>
            Contains returns true if the specified element is in the List.
            It does a linear, O(n) search.  Equality is determined by calling
            EqualityComparer{T}.Default.Equals.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.CopyTo(System.Span{`0})">
            <summary>
            Copies this list to the given span.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the capacity of this list is at least the given minimum
            value. If the current capacity of the list is less than min, the
            capacity is increased to twice the current capacity or to min,
            whichever is larger.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.GetEnumerator">
            <summary>
            Returns an enumerator for this list with the given
            permission for removal of elements. If modifications made to the list 
            while an enumeration is in progress, the MoveNext and 
            GetObject methods of the enumerator will throw an exception.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.GetRange(System.Int32,System.Int32)">
            <summary>
            Equivalent to PooledList.Span.Slice(index, count).
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.IndexOf(`0)">
            <summary>
            Returns the index of the first occurrence of a given value in
            this list. The list is searched forwards from beginning to end.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.IndexOf(`0,System.Int32)">
            <summary>
            Returns the index of the first occurrence of a given value in a range of
            this list. The list is searched forwards, starting at index
            index and ending at count number of elements. 
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Returns the index of the first occurrence of a given value in a range of
            this list. The list is searched forwards, starting at index
            index and upto count number of elements. 
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an element into this list at a given index. The size of the list
            is increased by one. If required, the capacity of the list is doubled
            before inserting the new element.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts the elements of the given collection at a given index. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.  Ranges may be added
            to the end of the list by setting index to the List's size.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.InsertRange(System.Int32,System.ReadOnlySpan{`0})">
            <summary>
            Inserts the elements of the given collection at a given index. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.  Ranges may be added
            to the end of the list by setting index to the List's size.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.InsertRange(System.Int32,`0[])">
            <summary>
            Inserts the elements of the given collection at a given index. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.  Ranges may be added
            to the end of the list by setting index to the List's size.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.InsertSpan(System.Int32,System.Int32)">
            <summary>
            Advances the <see cref="P:Collections.Pooled.PooledList`1.Count"/> by the number of items specified,
            increasing the capacity if required, then returns a Span representing
            the set of items to be added, allowing direct writes to that section
            of the collection.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.LastIndexOf(`0)">
            <summary>
            Returns the index of the last occurrence of a given value in a range of
            this list. The list is searched backwards, starting at the end 
            and ending at the first element in the list.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.LastIndexOf(`0,System.Int32)">
            <summary>
            Returns the index of the last occurrence of a given value in a range of
            this list. The list is searched backwards, starting at index
            index and ending at the first element in the list.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Returns the index of the last occurrence of a given value in a range of
            this list. The list is searched backwards, starting at index
            index and upto count elements
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.RemoveAll(System.Func{`0,System.Boolean})">
            <summary>
            This method removes all items which match the predicate.
            The complexity is O(n).
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the given index. The size of the list is
            decreased by one.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Removes a range of elements from this list.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.Reverse">
            <summary>
            Reverses the elements in this list.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.Reverse(System.Int32,System.Int32)">
            <summary>
            Reverses the elements in a range of this list. Following a call to this
            method, an element in the range given by index and count
            which was previously located at index i will now be located at
            index index + (index + count - i - 1).
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.Sort">
            <summary>
            Sorts the elements in this list.  Uses the default comparer and 
            Array.Sort.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in this list.  Uses Array.Sort with the
            provided comparer.
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in a section of this list. The sort compares the
            elements to each other using the given IComparer interface. If
            comparer is null, the elements are compared to each other using
            the IComparable interface, which in that case must be implemented by all
            elements of the list.
            
            This method uses the Array.Sort method to sort the elements.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.ToArray">
            <summary>
            ToArray returns an array containing the contents of the List.
            This requires copying the List, which is an O(n) operation.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.TrimExcess">
            <summary>
            Sets the capacity of this list to the size of the list. This method can
            be used to minimize a list's memory overhead once it is known that no
            new elements will be added to the list. To completely clear a list and
            release all memory referenced by the list, execute the following
            statements:
            <code>
            list.Clear();
            list.TrimExcess();
            </code>
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledList`1.Dispose">
            <summary>
            Returns the internal buffers to the ArrayPool.
            </summary>
        </member>
        <member name="T:Collections.Pooled.PooledMemory`1">
            <summary>
            Pooled <see cref="T:System.Buffers.IMemoryOwner`1"/> implementation that uses <see cref="T:System.Buffers.ArrayPool`1"/> as the backing store.
            The exposed Memory Region is constrained to exactly the requested length. This differs from default <see cref="T:System.Buffers.ArrayPool`1"/> or <see cref="T:System.Buffers.MemoryManager`1"/> behavior that may return an array with a length greater than requested.
            Also exposes <see cref="T:System.Collections.Generic.IEnumerable`1"/>, <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>, and indexer for element access.
            See <see href="https://learn.microsoft.com/dotnet/api/system.buffers.imemoryowner-1"/> for more information on <see cref="T:System.Buffers.IMemoryOwner`1"/>.
            </summary>
            <typeparam name="T">Element type.</typeparam>
        </member>
        <member name="P:Collections.Pooled.PooledMemory`1.Count">
            <summary>
            Gets the number of elements in this block of memory.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledMemory`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index in this block of memory.
            </summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index in this block of memory.</returns>
        </member>
        <member name="P:Collections.Pooled.PooledMemory`1.Memory">
            <summary>
            <see cref="T:System.Memory`1"/> representing this block of memory.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledMemory`1.Span">
            <summary>
            <see cref="T:System.Span`1"/> representing this block of memory.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledMemory`1.ClearMode">
            <summary>
            Returns the ClearMode behavior for this memory owner.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.#ctor">
            <summary>
            Initializes a new default instance of the <see cref="T:Collections.Pooled.PooledMemory`1"/> class with zero elements.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledMemory`1"/> class by renting a buffer of the specified length
            from an <see cref="T:System.Buffers.ArrayPool`1"/> and constraining the logical length to the requested <paramref name="count"/>.
            </summary>
            <param name="count">The number of elements in this memory block. Must be non-negative.</param>
            <remarks>
            The underlying rented array may be larger than <paramref name="count"/>; the logical length is constrained to <paramref name="count"/>.
            Uses <see cref="P:System.Buffers.ArrayPool`1.Shared"/> and ClearMode.Auto by default.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is less than 0.</exception>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.#ctor(System.Int32,Collections.Pooled.ClearMode)">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledMemory`1"/> class by renting a buffer of the specified length
            and configuring the clearing behavior when returning to the pool.
            </summary>
            <param name="count">The number of elements in this memory block. Must be non-negative.</param>
            <param name="clearMode">
            Specifies whether the underlying array should be cleared when returned to the pool:
            <see cref="F:Collections.Pooled.ClearMode.Always"/>, <see cref="F:Collections.Pooled.ClearMode.Never"/>, or <see cref="F:Collections.Pooled.ClearMode.Auto"/> (clears for reference-containing types).
            </param>
            <remarks>Uses <see cref="P:System.Buffers.ArrayPool`1.Shared"/> as the backing pool.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is less than 0.</exception>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.#ctor(System.Int32,System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledMemory`1"/> class by renting a buffer of the specified length
            from a custom <see cref="T:System.Buffers.ArrayPool`1"/>.
            </summary>
            <param name="count">The number of elements in this memory block. Must be non-negative.</param>
            <param name="customPool">
            The pool to rent from. If null, <see cref="P:System.Buffers.ArrayPool`1.Shared"/> is used.
            </param>
            <remarks>Uses <see cref="F:Collections.Pooled.ClearMode.Auto"/> for clearing behavior.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is less than 0.</exception>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.#ctor(System.Int32,Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledMemory`1"/> class by renting a buffer of the specified length
            from the provided <see cref="T:System.Buffers.ArrayPool`1"/> and configuring the clearing behavior.
            </summary>
            <param name="count">The number of elements in this memory block. Must be non-negative.</param>
            <param name="clearMode">
            Specifies whether the underlying array should be cleared when returned to the pool:
            <see cref="F:Collections.Pooled.ClearMode.Always"/>, <see cref="F:Collections.Pooled.ClearMode.Never"/>, or <see cref="F:Collections.Pooled.ClearMode.Auto"/> (clears for reference-containing types).
            </param>
            <param name="customPool">
            The pool to rent from. If null, <see cref="P:System.Buffers.ArrayPool`1.Shared"/> is used.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is less than 0.</exception>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledMemory`1"/> class by copying the contents of the specified
            <see cref="T:System.ReadOnlySpan`1"/> into a buffer rented from <see cref="P:System.Buffers.ArrayPool`1.Shared"/>.
            </summary>
            <param name="span">The source elements to copy into the new memory block.</param>
            <remarks>Uses <see cref="F:Collections.Pooled.ClearMode.Auto"/> for clearing behavior.</remarks>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.#ctor(System.ReadOnlySpan{`0},Collections.Pooled.ClearMode)">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledMemory`1"/> class by copying the contents of the specified
            <see cref="T:System.ReadOnlySpan`1"/> into a buffer, configuring the clearing behavior.
            </summary>
            <param name="span">The source elements to copy into the new memory block.</param>
            <param name="clearMode">
            Specifies whether the underlying array should be cleared when returned to the pool:
            <see cref="F:Collections.Pooled.ClearMode.Always"/>, <see cref="F:Collections.Pooled.ClearMode.Never"/>, or <see cref="F:Collections.Pooled.ClearMode.Auto"/> (clears for reference-containing types).
            </param>
            <remarks>Uses <see cref="P:System.Buffers.ArrayPool`1.Shared"/> as the backing pool.</remarks>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.#ctor(System.ReadOnlySpan{`0},System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledMemory`1"/> class by copying the contents of the specified
            <see cref="T:System.ReadOnlySpan`1"/> into a buffer rented from a custom <see cref="T:System.Buffers.ArrayPool`1"/>.
            </summary>
            <param name="span">The source elements to copy into the new memory block.</param>
            <param name="customPool">
            The pool to rent from. If null, <see cref="P:System.Buffers.ArrayPool`1.Shared"/> is used.
            </param>
            <remarks>Uses <see cref="F:Collections.Pooled.ClearMode.Auto"/> for clearing behavior.</remarks>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.#ctor(System.ReadOnlySpan{`0},Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledMemory`1"/> class by copying the contents of the specified
            <see cref="T:System.ReadOnlySpan`1"/> into a buffer rented from the provided <see cref="T:System.Buffers.ArrayPool`1"/> and configuring the clearing behavior.
            </summary>
            <param name="span">The source elements to copy into the new memory block.</param>
            <param name="clearMode">
            Specifies whether the underlying array should be cleared when returned to the pool:
            <see cref="F:Collections.Pooled.ClearMode.Always"/>, <see cref="F:Collections.Pooled.ClearMode.Never"/>, or <see cref="F:Collections.Pooled.ClearMode.Auto"/> (clears for reference-containing types).
            </param>
            <param name="customPool">
            The pool to rent from. If null, <see cref="P:System.Buffers.ArrayPool`1.Shared"/> is used.
            </param>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledMemory`1"/> class by copying the contents of the specified
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> into a buffer rented from <see cref="P:System.Buffers.ArrayPool`1.Shared"/>.
            </summary>
            <param name="enumerable">The source sequence whose elements will be copied into the new memory block.</param>
            <remarks>Uses <see cref="F:Collections.Pooled.ClearMode.Auto"/> for clearing behavior.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumerable"/> is null.</exception>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledMemory`1"/> class by copying the contents of the specified
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> into a buffer rented from <see cref="P:System.Buffers.ArrayPool`1.Shared"/>.
            </summary>
            <param name="enumerable">The source sequence whose elements will be copied into the new memory block.</param>
            <param name="suggestCapacity">
            The suggested initial capacity when the size of <paramref name="enumerable"/> is not known.
            </param>
            <remarks>Uses <see cref="F:Collections.Pooled.ClearMode.Auto"/> for clearing behavior.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumerable"/> is null.</exception>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.#ctor(System.Collections.Generic.IEnumerable{`0},Collections.Pooled.ClearMode)">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledMemory`1"/> class by copying the contents of the specified
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> into a buffer and configuring the clearing behavior.
            </summary>
            <param name="enumerable">The source sequence whose elements will be copied into the new memory block.</param>
            <param name="clearMode">
            Specifies whether the underlying array should be cleared when returned to the pool:
            <see cref="F:Collections.Pooled.ClearMode.Always"/>, <see cref="F:Collections.Pooled.ClearMode.Never"/>, or <see cref="F:Collections.Pooled.ClearMode.Auto"/> (clears for reference-containing types).
            </param>
            <remarks>Uses <see cref="P:System.Buffers.ArrayPool`1.Shared"/> as the backing pool.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumerable"/> is null.</exception>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledMemory`1"/> class by copying the contents of the specified
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> into a buffer rented from a custom <see cref="T:System.Buffers.ArrayPool`1"/>.
            </summary>
            <param name="enumerable">The source sequence whose elements will be copied into the new memory block.</param>
            <param name="customPool">
            The pool to rent from. If null, <see cref="P:System.Buffers.ArrayPool`1.Shared"/> is used.
            </param>
            <remarks>Uses <see cref="F:Collections.Pooled.ClearMode.Auto"/> for clearing behavior.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumerable"/> is null.</exception>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.#ctor(System.Collections.Generic.IEnumerable{`0},Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0},System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledMemory`1"/> class by copying the contents of the specified
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> into a buffer rented from the provided <see cref="T:System.Buffers.ArrayPool`1"/> and configuring the clearing behavior.
            </summary>
            <param name="enumerable">The source sequence whose elements will be copied into the new memory block.</param>
            <param name="clearMode">
            Specifies whether the underlying array should be cleared when returned to the pool:
            <see cref="F:Collections.Pooled.ClearMode.Always"/>, <see cref="F:Collections.Pooled.ClearMode.Never"/>, or <see cref="F:Collections.Pooled.ClearMode.Auto"/> (clears for reference-containing types).
            </param>
            <param name="customPool">
            The pool to rent from. If null, <see cref="P:System.Buffers.ArrayPool`1.Shared"/> is used.
            </param>
            <param name="suggestCapacity">
            The suggested initial capacity when the size of <paramref name="enumerable"/> is not known.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumerable"/> is null.</exception>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Collections.Pooled.PooledMemory`1.Dispose">
            <summary>
            Disposes the <see cref="T:Collections.Pooled.PooledMemory`1"/> instance, returning the underlying array to the pool.
            </summary>
        </member>
        <member name="T:Collections.Pooled.PooledQueue`1">
            <summary>
            A simple Queue of generic objects.  Internally it is implemented as a 
            circular buffer, so Enqueue can be O(n).  Dequeue is O(1).
            </summary>
            <typeparam name="T">The type to store in the queue.</typeparam>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(Collections.Pooled.ClearMode)">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that is empty and has the specified initial capacity.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(System.Int32,Collections.Pooled.ClearMode)">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that is empty and has the specified initial capacity.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(System.Int32,System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that is empty and has the specified initial capacity.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(System.Int32,Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that is empty and has the specified initial capacity.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that contains elements copied from the specified 
            collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},Collections.Pooled.ClearMode)">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that contains elements copied from the specified 
            collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that contains elements copied from the specified 
            collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that contains elements copied from the specified 
            collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(`0[])">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that contains elements copied from the specified 
            array and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(`0[],Collections.Pooled.ClearMode)">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that contains elements copied from the specified 
            array and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(`0[],System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that contains elements copied from the specified 
            array and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(`0[],Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that contains elements copied from the specified 
            array and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that contains elements copied from the specified 
            span and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(System.ReadOnlySpan{`0},Collections.Pooled.ClearMode)">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that contains elements copied from the specified 
            span and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(System.ReadOnlySpan{`0},System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that contains elements copied from the specified 
            span and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.#ctor(System.ReadOnlySpan{`0},Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Collections.Pooled.PooledQueue`1"/> class that contains elements copied from the specified 
            span and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledQueue`1.Count">
            <summary>
            The number of items in the queue.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledQueue`1.ClearMode">
            <summary>
            Returns the ClearMode behavior for the collection, denoting whether values are
            cleared from internal arrays before returning them to the pool.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.Clear">
            <summary>
            Removes all objects from the queue.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.CopyTo(`0[],System.Int32)">
            <summary>
            CopyTo copies a collection into an Array, starting at a particular
            index into the array.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.Enqueue(`0)">
            <summary>
            Adds <paramref name="item"/> to the tail of the queue.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.GetEnumerator">
            <summary>
            GetEnumerator returns an IEnumerator over this Queue.  This
            Enumerator will support removing.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <internalonly/>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.Dequeue">
            <summary>
            Removes the object at the head of the queue and returns it. If the queue
            is empty, this method throws an 
            <see cref="T:System.InvalidOperationException"/>.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.Peek">
            <summary>
            Returns the object at the head of the queue. The object remains in the
            queue. If the queue is empty, this method throws an 
            <see cref="T:System.InvalidOperationException"/>.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.Contains(`0)">
            <summary>
            Returns true if the queue contains at least one object equal to item.
            Equality is determined using <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.RemoveWhere(System.Func{`0,System.Boolean})">
            <summary>
            This method removes all items from the queue which match the predicate.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledQueue`1.ToArray">
            <summary>
            Iterates over the objects in the queue, returning an array of the
            objects in the Queue, or an empty array if the queue is empty.
            The order of elements in the array is first in to last in, the same
            order produced by successive calls to Dequeue.
            </summary>
        </member>
        <member name="T:Collections.Pooled.PooledSet`1">
            <summary>
            Represents a set of values.
            </summary>
            <remarks>
            Implementation notes:
            This uses an array-based implementation similar to <see cref="T:System.Collections.Generic.Dictionary`2"/>, using a buckets array
            to map hash values to the Slots array. Items in the Slots array that hash to the same value
            are chained together through the "next" indices. 
            
            The capacity is always prime; so during resizing, the capacity is chosen as the next prime
            greater than double the last capacity. 
            
            The underlying data structures are lazily initialized. Because of the observation that, 
            in practice, hashtables tend to contain only a few elements, the initial capacity is
            set very small (3 elements) unless the ctor with a collection is used.
            
            The +/- 1 modifications in methods that add, check for containment, etc allow us to 
            distinguish a hash code of 0 from an uninitialized bucket. This saves us from having to 
            reset each bucket to -1 when resizing. See Contains, for example.
            
            Set methods such as UnionWith, IntersectWith, ExceptWith, and SymmetricExceptWith modify
            this set.
            
            Some operations can perform faster if we can assume "other" contains unique elements
            according to this equality comparer. The only times this is efficient to check is if
            other is a hashset. Note that checking that it's a hashset alone doesn't suffice; we
            also have to check that the hashset is using the same equality comparer. If other 
            has a different equality comparer, it will have unique elements according to its own
            equality comparer, but not necessarily according to ours. Therefore, to go these 
            optimized routes we check that other is a hashset using the same equality comparer.
            
            A HashSet with no elements has the properties of the empty set. (See IsSubset, etc. for 
            special empty set checks.)
            
            A couple of methods have a special case if other is this (e.g. SymmetricExceptWith). 
            If we didn't have these checks, we could be iterating over the set and modifying at
            the same time. 
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(Collections.Pooled.ClearMode)">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(Collections.Pooled.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(System.Int32)">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(System.Int32,Collections.Pooled.ClearMode)">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(System.Int32,Collections.Pooled.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},Collections.Pooled.ClearMode)">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},Collections.Pooled.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Implementation Notes:
            Since resizes are relatively expensive (require rehashing), this attempts to minimize 
            the need to resize by setting the initial capacity based on size of collection. 
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(`0[])">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(`0[],Collections.Pooled.ClearMode)">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(`0[],System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(`0[],Collections.Pooled.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(System.ReadOnlySpan{`0},Collections.Pooled.ClearMode)">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(System.ReadOnlySpan{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(System.ReadOnlySpan{`0},Collections.Pooled.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Add item to this hashset. This is the explicit implementation of the <see cref="T:System.Collections.Generic.ICollection`1"/>
            interface. The other Add method returns bool indicating whether item was added.
            </summary>
            <param name="item">item to add</param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.Clear">
            <summary>
            Remove all items from this set. This clears the elements but not the underlying 
            buckets and slots array. Follow this call by TrimExcess to release these.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.Contains(`0)">
            <summary>
            Checks if this hashset contains the item
            </summary>
            <param name="item">item to check for containment</param>
            <returns>true if item contained; false if not</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy items in this hashset to array, starting at arrayIndex
            </summary>
            <param name="array">array to add items to</param>
            <param name="arrayIndex">index to start at</param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.Remove(`0)">
            <summary>
            Remove item from this hashset
            </summary>
            <param name="item">item to remove</param>
            <returns>true if removed; false if not (i.e. if the item wasn't in the HashSet)</returns>
        </member>
        <member name="P:Collections.Pooled.PooledSet`1.Count">
            <summary>
            Number of elements in this set
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledSet`1.ClearMode">
            <summary>
            Returns the ClearMode behavior for the collection, denoting whether values are
            cleared from internal arrays before returning them to the pool.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledSet`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Whether this is readonly
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.GetEnumerator">
            <summary>
            Gets an enumerator with which to enumerate the set.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Gets object data for serialization.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.OnDeserialization(System.Object)">
            <summary>
            Deserialization callback.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.Add(`0)">
            <summary>
            Add item to this PooledSet. Returns bool indicating whether item was added (won't be 
            added if already present)
            </summary>
            <param name="item"></param>
            <returns>true if added, false if already present</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.TryGetValue(`0,`0@)">
            <summary>
            Searches the set for a given value and returns the equal value it finds, if any.
            </summary>
            <param name="equalValue">The value to search for.</param>
            <param name="actualValue">The value from the set that the search found, or the default value of <typeparamref name="T"/> when the search yielded no match.</param>
            <returns>A value indicating whether the search was successful.</returns>
            <remarks>
            This can be useful when you want to reuse a previously stored reference instead of 
            a newly constructed one (so that more sharing of references can occur) or to look up
            a value that has more complete data than the value you currently have, although their
            comparer functions indicate they are equal.
            </remarks>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Take the union of this HashSet with other. Modifies this set.
            </summary>
            <remarks>
            Implementation note: GetSuggestedCapacity (to increase capacity in advance avoiding 
            multiple resizes ended up not being useful in practice; quickly gets to the 
            point where it's a wasteful check.
            </remarks>
            <param name="other">enumerable with items to add</param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.UnionWith(`0[])">
            <summary>
            Take the union of this PooledSet with other. Modifies this set.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.UnionWith(System.ReadOnlySpan{`0})">
            <summary>
            Take the union of this PooledSet with other. Modifies this set.
            </summary>
            <param name="other">enumerable with items to add</param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Takes the intersection of this set with other. Modifies this set.
            </summary>
            <remarks>
            Implementation Notes: 
            We get better perf if other is a hashset using same equality comparer, because we 
            get constant contains check in other. Resulting cost is O(n1) to iterate over this.
            
            If we can't go above route, iterate over the other and mark intersection by checking
            contains in this. Then loop over and delete any unmarked elements. Total cost is n2+n1. 
            
            Attempts to return early based on counts alone, using the property that the 
            intersection of anything with the empty set is the empty set.
            </remarks>
            <param name="other">enumerable with items to add </param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IntersectWith(`0[])">
            <summary>
            Takes the intersection of this set with other. Modifies this set.
            </summary>
            <remarks>
            Implementation Notes: 
            Iterate over the other and mark intersection by checking
            contains in this. Then loop over and delete any unmarked elements. Total cost is n2+n1. 
            
            Attempts to return early based on counts alone, using the property that the 
            intersection of anything with the empty set is the empty set.
            </remarks>
            <param name="other">enumerable with items to add </param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IntersectWith(System.ReadOnlySpan{`0})">
            <summary>
            Takes the intersection of this set with other. Modifies this set.
            </summary>
            <remarks>
            Implementation Notes: 
            Iterate over the other and mark intersection by checking
            contains in this. Then loop over and delete any unmarked elements. Total cost is n2+n1. 
            
            Attempts to return early based on counts alone, using the property that the 
            intersection of anything with the empty set is the empty set.
            </remarks>
            <param name="other">enumerable with items to add </param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove items in other from this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to remove</param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.ExceptWith(`0[])">
            <summary>
            Remove items in other from this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to remove</param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.ExceptWith(System.ReadOnlySpan{`0})">
            <summary>
            Remove items in other from this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to remove</param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Takes symmetric difference (XOR) with other and this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to XOR</param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.SymmetricExceptWith(`0[])">
            <summary>
            Takes symmetric difference (XOR) with other and this set. Modifies this set.
            </summary>
            <param name="other">array with items to XOR</param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.SymmetricExceptWith(System.ReadOnlySpan{`0})">
            <summary>
            Takes symmetric difference (XOR) with other and this set. Modifies this set.
            </summary>
            <param name="other">span with items to XOR</param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a subset of other.
            </summary>
            <remarks>
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it's a subset of anything, including the empty set
            2. If other has unique elements according to this equality comparer, and this has more
            elements than other, then it can't be a subset.
            
            Furthermore, if other is a hashset using the same equality comparer, we can use a 
            faster element-wise check.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a subset of other; false if not</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IsSubsetOf(`0[])">
            <summary>
            Checks if this is a subset of other.
            </summary>
            <param name="other"></param>
            <returns>true if this is a subset of other; false if not</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IsSubsetOf(System.ReadOnlySpan{`0})">
            <summary>
            Checks if this is a subset of other.
            </summary>
            <param name="other"></param>
            <returns>true if this is a subset of other; false if not</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a proper subset of other (i.e. strictly contained in)
            </summary>
            <remarks>
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it's a proper subset of a set that contains at least
            one element, but it's not a proper subset of the empty set.
            2. If other has unique elements according to this equality comparer, and this has >=
            the number of elements in other, then this can't be a proper subset.
            
            Furthermore, if other is a hashset using the same equality comparer, we can use a 
            faster element-wise check.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a proper subset of other; false if not</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IsProperSubsetOf(`0[])">
            <summary>
            Checks if this is a proper subset of other (i.e. strictly contained in)
            </summary>
            <remarks>
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it's a proper subset of a set that contains at least
            one element, but it's not a proper subset of the empty set.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a proper subset of other; false if not</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IsProperSubsetOf(System.ReadOnlySpan{`0})">
            <summary>
            Checks if this is a proper subset of other (i.e. strictly contained in)
            </summary>
            <remarks>
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it's a proper subset of a set that contains at least
            one element, but it's not a proper subset of the empty set.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a proper subset of other; false if not</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a superset of other
            </summary>
            <remarks>
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If other has no elements (it's the empty set), then this is a superset, even if this
            is also the empty set.
            2. If other has unique elements according to this equality comparer, and this has less 
            than the number of elements in other, then this can't be a superset
            </remarks>
            <param name="other"></param>
            <returns>true if this is a superset of other; false if not</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IsSupersetOf(`0[])">
            <summary>
            Checks if this is a superset of other
            </summary>
            <remarks>
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If other has no elements (it's the empty set), then this is a superset, even if this
            is also the empty set.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a superset of other; false if not</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IsSupersetOf(System.ReadOnlySpan{`0})">
            <summary>
            Checks if this is a superset of other
            </summary>
            <remarks>
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If other has no elements (it's the empty set), then this is a superset, even if this
            is also the empty set.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a superset of other; false if not</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a proper superset of other (i.e. other strictly contained in this)
            </summary>
            <remarks>
            Implementation Notes: 
            This is slightly more complicated than IsSupersetOf because we have to keep track if there
            was at least one element not contained in other.
            
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it can't be a proper superset of any set, even if 
            other is the empty set.
            2. If other is an empty set and this contains at least 1 element, then this is a proper
            superset.
            3. If other has unique elements according to this equality comparer, and other's count
            is greater than or equal to this count, then this can't be a proper superset
            
            Furthermore, if other has unique elements according to this equality comparer, we can
            use a faster element-wise check.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a proper superset of other; false if not</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IsProperSupersetOf(`0[])">
            <summary>
            Checks if this is a proper superset of other (i.e. other strictly contained in this)
            </summary>
            <remarks>
            Implementation Notes: 
            This is slightly more complicated than IsSupersetOf because we have to keep track if there
            was at least one element not contained in other.
            
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it can't be a proper superset of any set, even if 
            other is the empty set.
            2. If other is an empty set and this contains at least 1 element, then this is a proper
            superset.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a proper superset of other; false if not</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IsProperSupersetOf(System.ReadOnlySpan{`0})">
            <summary>
            Checks if this is a proper superset of other (i.e. other strictly contained in this)
            </summary>
            <remarks>
            Implementation Notes: 
            This is slightly more complicated than IsSupersetOf because we have to keep track if there
            was at least one element not contained in other.
            
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it can't be a proper superset of any set, even if 
            other is the empty set.
            2. If other is an empty set and this contains at least 1 element, then this is a proper
            superset.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a proper superset of other; false if not</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this set overlaps other (i.e. they share at least one item)
            </summary>
            <param name="other"></param>
            <returns>true if these have at least one common element; false if disjoint</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.Overlaps(`0[])">
            <summary>
            Checks if this set overlaps other (i.e. they share at least one item)
            </summary>
            <param name="other"></param>
            <returns>true if these have at least one common element; false if disjoint</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.Overlaps(System.ReadOnlySpan{`0})">
            <summary>
            Checks if this set overlaps other (i.e. they share at least one item)
            </summary>
            <param name="other"></param>
            <returns>true if these have at least one common element; false if disjoint</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this and other contain the same elements. This is set equality: 
            duplicates and order are ignored
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.SetEquals(`0[])">
            <summary>
            Checks if this and other contain the same elements. This is set equality: 
            duplicates and order are ignored
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.SetEquals(System.ReadOnlySpan{`0})">
            <summary>
            Checks if this and other contain the same elements. This is set equality: 
            duplicates and order are ignored
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.CopyTo(`0[])">
            <summary>
            Copies the set to the given array.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.CopyTo(`0[],System.Int32,System.Int32)">
            <summary>
            Copies <paramref name="count"/> items of the set to the given array, starting 
            at <paramref name="arrayIndex"/> in the destination array.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.CopyTo(System.Span{`0})">
            <summary>
            Copies the set to the given span.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.CopyTo(System.Span{`0},System.Int32)">
            <summary>
            Copies <paramref name="count"/> items from the set to the given span.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.RemoveWhere(System.Func{`0,System.Boolean})">
            <summary>
            Remove elements that match specified predicate. Returns the number of elements removed
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="P:Collections.Pooled.PooledSet`1.Comparer">
            <summary>
            Gets the IEqualityComparer that is used to determine equality of keys for 
            the HashSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the hash set can hold up to 'capacity' entries without any further expansion of its backing storage.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.TrimExcess">
            <summary>
            Sets the capacity of this list to the size of the list (rounded up to nearest prime),
            unless count is 0, in which case we release references.
            
            This method can be used to minimize a list's memory overhead once it is known that no
            new elements will be added to the list. To completely clear a list and release all 
            memory referenced by the list, execute the following statements:
            
            list.Clear();
            list.TrimExcess(); 
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.CreateSetComparer">
            <summary>
            Used for deep equality of HashSet testing
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.Initialize(System.Int32)">
            <summary>
            Initializes buckets and slots arrays. Uses suggested capacity by finding next prime
            greater than or equal to capacity.
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IncreaseCapacity">
            <summary>
            Expand to new capacity. New capacity is next prime greater than or equal to suggested 
            size. This is called when the underlying array is filled. This performs no 
            defragmentation, allowing faster execution; note that this is reasonable since 
            AddIfNotPresent attempts to insert new elements in re-opened spots.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.SetCapacity(System.Int32)">
            <summary>
            Set the underlying buckets array to size newSize and rehash.  Note that newSize
            *must* be a prime.  It is very likely that you want to call IncreaseCapacity()
            instead of this method.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.AddIfNotPresent(`0)">
            <summary>
            Adds value to HashSet if not contained already
            Returns true if added and false if already present
            </summary>
            <param name="value">value to find</param>
            <returns></returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.ContainsAllElements(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this contains of other's elements. Iterates over other's elements and 
            returns false as soon as it finds an element in other that's not in this.
            Used by SupersetOf, ProperSupersetOf, and SetEquals.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.ContainsAllElements(System.ReadOnlySpan{`0})">
            <summary>
            Checks if this contains of other's elements. Iterates over other's elements and 
            returns false as soon as it finds an element in other that's not in this.
            Used by SupersetOf, ProperSupersetOf, and SetEquals.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IsSubsetOfHashSetWithSameEC(Collections.Pooled.PooledSet{`0})">
             <summary>
             Implementation Notes:
             If other is a hashset and is using same equality comparer, then checking subset is 
             faster. Simply check that each element in this is in other.
             
             Note: if other doesn't use same equality comparer, then Contains check is invalid,
             which is why callers must take are of this.
             
             If callers are concerned about whether this is a proper subset, they take care of that.
            
             </summary>
             <param name="other"></param>
             <returns></returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IsSubsetOfHashSetWithSameEC(System.Collections.Generic.HashSet{`0})">
             <summary>
             Implementation Notes:
             If other is a hashset and is using same equality comparer, then checking subset is 
             faster. Simply check that each element in this is in other.
             
             Note: if other doesn't use same equality comparer, then Contains check is invalid,
             which is why callers must take are of this.
             
             If callers are concerned about whether this is a proper subset, they take care of that.
            
             </summary>
             <param name="other"></param>
             <returns></returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IntersectWithHashSetWithSameEC(Collections.Pooled.PooledSet{`0})">
            <summary>
            If other is a hashset that uses same equality comparer, intersect is much faster 
            because we can use other's Contains
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IntersectWithHashSetWithSameEC(System.Collections.Generic.HashSet{`0})">
            <summary>
            If other is a hashset that uses same equality comparer, intersect is much faster 
            because we can use other's Contains
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IntersectWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Iterate over other. If contained in this, mark an element in bit array corresponding to
            its position in _slots. If anything is unmarked (in bit array), remove it.
            
            This attempts to allocate on the stack, if below StackAllocThreshold.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.IntersectWithSpan(System.ReadOnlySpan{`0})">
            <summary>
            Iterate over other. If contained in this, mark an element in bit array corresponding to
            its position in _slots. If anything is unmarked (in bit array), remove it.
            
            This attempts to allocate on the stack, if below StackAllocThreshold.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.InternalIndexOf(`0)">
            <summary>
            Used internally by set operations which have to rely on bit array marking. This is like
            Contains but returns index in slots array. 
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.SymmetricExceptWithUniqueHashSet(Collections.Pooled.PooledSet{`0})">
            <summary>
            if other is a set, we can assume it doesn't have duplicate elements, so use this
            technique: if can't remove, then it wasn't present in this set, so add.
            
            As with other methods, callers take care of ensuring that other is a hashset using the
            same equality comparer.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.SymmetricExceptWithUniqueHashSet(System.Collections.Generic.HashSet{`0})">
            <summary>
            if other is a set, we can assume it doesn't have duplicate elements, so use this
            technique: if can't remove, then it wasn't present in this set, so add.
            
            As with other methods, callers take care of ensuring that other is a hashset using the
            same equality comparer.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.SymmetricExceptWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Implementation notes:
             
             Used for symmetric except when other isn't a HashSet. This is more tedious because 
             other may contain duplicates. HashSet technique could fail in these situations:
             1. Other has a duplicate that's not in this: HashSet technique would add then 
             remove it.
             2. Other has a duplicate that's in this: HashSet technique would remove then add it
             back.
             In general, its presence would be toggled each time it appears in other. 
             
             This technique uses bit marking to indicate whether to add/remove the item. If already
             present in collection, it will get marked for deletion. If added from other, it will
             get marked as something not to remove.
            
             </summary>
             <param name="other"></param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.SymmetricExceptWithSpan(System.ReadOnlySpan{`0})">
             <summary>
             Implementation notes:
             
             Used for symmetric except when other isn't a HashSet. This is more tedious because 
             other may contain duplicates. HashSet technique could fail in these situations:
             1. Other has a duplicate that's not in this: HashSet technique would add then 
             remove it.
             2. Other has a duplicate that's in this: HashSet technique would remove then add it
             back.
             In general, its presence would be toggled each time it appears in other. 
             
             This technique uses bit marking to indicate whether to add/remove the item. If already
             present in collection, it will get marked for deletion. If added from other, it will
             get marked as something not to remove.
            
             </summary>
             <param name="other"></param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.AddOrGetLocation(`0,System.Int32@)">
            <summary>
            Add if not already in hashset. Returns an out param indicating index where added. This 
            is used by SymmetricExcept because it needs to know the following things:
            - whether the item was already present in the collection or added from other
            - where it's located (if already present, it will get marked for removal, otherwise
            marked for keeping)
            </summary>
            <param name="value"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.CheckUniqueAndUnfoundElements(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
            Determines counts that can be used to determine equality, subset, and superset. This
            is only used when other is an IEnumerable and not a HashSet. If other is a HashSet
            these properties can be checked faster without use of marking because we can assume 
            other has no duplicates.
            
            The following count checks are performed by callers:
            1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = _count; i.e. everything 
            in other is in this and everything in this is in other
            2. Subset: checks if unfoundCount >= 0 and uniqueFoundCount = _count; i.e. other may
            have elements not in this and everything in this is in other
            3. Proper subset: checks if unfoundCount > 0 and uniqueFoundCount = _count; i.e
            other must have at least one element not in this and everything in this is in other
            4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
            than _count; i.e. everything in other was in this and this had at least one element
            not contained in other.
            
            An earlier implementation used delegates to perform these checks rather than returning
            an ElementCount struct; however this was changed due to the perf overhead of delegates.
            </summary>
            <param name="other"></param>
            <param name="returnIfUnfound">Allows us to finish faster for equals and proper superset
            because unfoundCount must be 0.</param>
            <returns></returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.CheckUniqueAndUnfoundElements(System.ReadOnlySpan{`0},System.Boolean)">
            <summary>
            Determines counts that can be used to determine equality, subset, and superset. This
            is only used when other is a Span and not a HashSet. If other is a HashSet
            these properties can be checked faster without use of marking because we can assume 
            other has no duplicates.
            
            The following count checks are performed by callers:
            1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = _count; i.e. everything 
            in other is in this and everything in this is in other
            2. Subset: checks if unfoundCount >= 0 and uniqueFoundCount = _count; i.e. other may
            have elements not in this and everything in this is in other
            3. Proper subset: checks if unfoundCount > 0 and uniqueFoundCount = _count; i.e
            other must have at least one element not in this and everything in this is in other
            4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
            than _count; i.e. everything in other was in this and this had at least one element
            not contained in other.
            
            An earlier implementation used delegates to perform these checks rather than returning
            an ElementCount struct; however this was changed due to the perf overhead of delegates.
            </summary>
            <param name="other"></param>
            <param name="returnIfUnfound">Allows us to finish faster for equals and proper superset
            because unfoundCount must be 0.</param>
            <returns></returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.PooledSetEquals(Collections.Pooled.PooledSet{`0},Collections.Pooled.PooledSet{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Internal method used for HashSetEqualityComparer. Compares set1 and set2 according 
            to specified comparer.
            
            Because items are hashed according to a specific equality comparer, we have to resort
            to n^2 search if they're using different equality comparers.
            </summary>
            <param name="set1"></param>
            <param name="set2"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.AreEqualityComparersEqual(Collections.Pooled.PooledSet{`0},Collections.Pooled.PooledSet{`0})">
            <summary>
            Checks if equality comparers are equal. This is used for algorithms that can
            speed up if it knows the other item has unique elements. I.e. if they're using 
            different equality comparers, then uniqueness assumption between sets break.
            </summary>
            <param name="set1"></param>
            <param name="set2"></param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.AreEqualityComparersEqual(Collections.Pooled.PooledSet{`0},System.Collections.Generic.HashSet{`0})">
            <summary>
            Checks if equality comparers are equal. This is used for algorithms that can
            speed up if it knows the other item has unique elements. I.e. if they're using 
            different equality comparers, then uniqueness assumption between sets break.
            </summary>
            <param name="set1"></param>
            <param name="set2"></param>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.InternalGetHashCode(`0)">
            <summary>
            Workaround Comparers that throw ArgumentNullException for GetHashCode(null).
            </summary>
            <param name="item"></param>
            <returns>hash code</returns>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.Dispose">
            <summary>
            Clears all values and returns internal arrays to the ArrayPool.
            </summary>
        </member>
        <member name="T:Collections.Pooled.PooledSet`1.Enumerator">
            <summary>
            Enumerates the PooledSet.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledSet`1.Enumerator.MoveNext">
            <summary>
            Moves to the next item in the set.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledSet`1.Enumerator.Current">
            <summary>
            Gets the current element in the set.
            </summary>
        </member>
        <member name="T:Collections.Pooled.PooledSetEqualityComparer`1">
            <summary>
            Equality comparer for hashsets of hashsets
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Collections.Pooled.PooledStack`1">
            <summary>
            A simple stack of objects.  Internally it is implemented as an array,
            so Push can be O(n).  Pop is O(1).
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor">
            <summary>
            Create a stack with the default initial capacity. 
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(Collections.Pooled.ClearMode)">
            <summary>
            Create a stack with the default initial capacity. 
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(System.Buffers.ArrayPool{`0})">
            <summary>
            Create a stack with the default initial capacity. 
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Create a stack with the default initial capacity and a custom ArrayPool.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(System.Int32)">
            <summary>
            Create a stack with a specific initial capacity.  The initial capacity
            must be a non-negative number.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(System.Int32,Collections.Pooled.ClearMode)">
            <summary>
            Create a stack with a specific initial capacity.  The initial capacity
            must be a non-negative number.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(System.Int32,System.Buffers.ArrayPool{`0})">
            <summary>
            Create a stack with a specific initial capacity.  The initial capacity
            must be a non-negative number.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(System.Int32,Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Create a stack with a specific initial capacity.  The initial capacity
            must be a non-negative number.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(System.Collections.Generic.IEnumerable{`0},Collections.Pooled.ClearMode)">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Buffers.ArrayPool{`0})">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(System.Collections.Generic.IEnumerable{`0},Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(`0[])">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(`0[],Collections.Pooled.ClearMode)">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(`0[],System.Buffers.ArrayPool{`0})">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(`0[],Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(System.ReadOnlySpan{`0},Collections.Pooled.ClearMode)">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(System.ReadOnlySpan{`0},System.Buffers.ArrayPool{`0})">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.#ctor(System.ReadOnlySpan{`0},Collections.Pooled.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledStack`1.Count">
            <summary>
            The number of items in the stack.
            </summary>
        </member>
        <member name="P:Collections.Pooled.PooledStack`1.ClearMode">
            <summary>
            Returns the ClearMode behavior for the collection, denoting whether values are
            cleared from internal arrays before returning them to the pool.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.Clear">
            <summary>
            Removes all Objects from the Stack.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.Contains(`0)">
            <summary>
            Compares items using the default equality comparer
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.RemoveWhere(System.Func{`0,System.Boolean})">
            <summary>
            This method removes all items which match the predicate.
            The complexity is O(n).
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.GetEnumerator">
            <summary>
            Returns an IEnumerator for this PooledStack.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <internalonly/>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.Peek">
            <summary>
            Returns the top object on the stack without removing it.  If the stack
            is empty, Peek throws an InvalidOperationException.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.Pop">
            <summary>
            Pops an item from the top of the stack.  If the stack is empty, Pop
            throws an InvalidOperationException.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.Push(`0)">
            <summary>
            Pushes an item to the top of the stack.
            </summary>
        </member>
        <member name="M:Collections.Pooled.PooledStack`1.ToArray">
            <summary>
            Copies the Stack to an array, in the same order Pop would return the items.
            </summary>
        </member>
    </members>
</doc>
